/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KanbanViewPlugin
});
module.exports = __toCommonJS(main_exports);

// KanbanView.ts
var import_obsidian = require("obsidian");

// KanbanCard.ts
var KanbanCard = class {
  constructor(propertyRenderer, propertyTypes, config, settings, app, moveItemToStatus) {
    this.propertyRenderer = propertyRenderer;
    this.propertyTypes = propertyTypes;
    this.config = config;
    this.settings = settings;
    this.app = app;
    this.moveItemToStatus = moveItemToStatus;
  }
  /**
   * Creates a Kanban card for an entry
   */
  createCard(entry) {
    const card = document.createElement("div");
    card.className = "kanban-card";
    card.setAttribute("draggable", "true");
    const itemId = entry.file?.path || entry.path || "";
    card.setAttribute("data-item-id", itemId);
    const title = card.createDiv("kanban-card-title");
    title.textContent = entry.file?.basename || entry.name || "Untitled";
    const propertiesContainer = card.createDiv("kanban-card-properties");
    const visibleProperties = this.config.getOrder();
    visibleProperties.forEach((propertyId) => {
      const propertyName = this.config.getDisplayName(propertyId);
      if (propertyName === this.settings.statusProperty) {
        return;
      }
      const value = entry.getValue ? entry.getValue(propertyId) : null;
      const prop = propertiesContainer.createDiv("kanban-card-property");
      prop.setAttribute("data-property", propertyId);
      const label = prop.createDiv("kanban-property-label");
      label.textContent = propertyName;
      const isEmpty = this.propertyRenderer.isValueEmpty(value);
      const valueContainer = prop.createDiv("kanban-property-value");
      let propertyType = this.propertyTypes[propertyName] || null;
      if (!propertyType && value && !isEmpty) {
        propertyType = this.propertyRenderer.inferPropertyType(value) || "text";
      }
      if (propertyType === "tags") {
        propertyType = "multitext";
      }
      valueContainer.setAttribute("data-property-type", propertyType || "text");
      if (!isEmpty) {
        try {
          this.propertyRenderer.renderPropertyValue(valueContainer, propertyId, value, entry.file);
        } catch (e) {
          this.propertyRenderer.renderText(valueContainer, value);
        }
      }
    });
    this.setupCardEvents(card, entry);
    return card;
  }
  /**
   * Configures drag and drop and click events for a card
   */
  setupCardEvents(card, entry) {
    let isDragging = false;
    let mouseDownX = 0;
    let mouseDownY = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let draggedCard = null;
    const DRAG_THRESHOLD = 5;
    card.addEventListener("mousedown", (e) => {
      mouseDownX = e.clientX;
      mouseDownY = e.clientY;
      isDragging = false;
    });
    card.addEventListener("dragstart", (e) => {
      isDragging = true;
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", card.getAttribute("data-item-id") || "");
      card.classList.add("dragging");
      card.classList.add("drag-start");
    });
    card.addEventListener("dragend", () => {
      card.classList.remove("dragging");
      card.classList.remove("drag-start");
      setTimeout(() => {
        isDragging = false;
      }, 100);
    });
    card.addEventListener("click", (e) => {
      if (isDragging) {
        return;
      }
      const mouseMoveX = Math.abs(e.clientX - mouseDownX);
      const mouseMoveY = Math.abs(e.clientY - mouseDownY);
      if (mouseMoveX > DRAG_THRESHOLD || mouseMoveY > DRAG_THRESHOLD) {
        return;
      }
      const target = e.target;
      if (target.tagName === "INPUT" || target.tagName === "A" || target.closest("input") || target.closest("a")) {
        return;
      }
      const filePath = card.getAttribute("data-item-id");
      if (filePath && entry.file) {
        this.app.workspace.openLinkText(filePath, "", false);
      }
    });
    card.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchStartTime = Date.now();
      isDragging = false;
      draggedCard = card;
    }, { passive: true });
    card.addEventListener("touchmove", (e) => {
      if (!draggedCard || draggedCard !== card)
        return;
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - touchStartX);
      const deltaY = Math.abs(touch.clientY - touchStartY);
      if ((deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) && !isDragging) {
        isDragging = true;
        card.classList.add("dragging");
        const rect = card.getBoundingClientRect();
        card.style.width = `${rect.width}px`;
        card.style.position = "fixed";
        card.style.zIndex = "10000";
        card.style.pointerEvents = "none";
        card.style.left = `${rect.left}px`;
        card.style.top = `${rect.top}px`;
        card.style.transform = `translate(${touch.clientX - touchStartX}px, ${touch.clientY - touchStartY}px)`;
        e.preventDefault();
      } else if (isDragging) {
        card.style.transform = `translate(${touch.clientX - touchStartX}px, ${touch.clientY - touchStartY}px)`;
        const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        const targetColumn = elementBelow?.closest(".kanban-column-body");
        document.querySelectorAll(".kanban-column-body.drag-over").forEach((el) => {
          el.classList.remove("drag-over");
        });
        if (targetColumn) {
          targetColumn.classList.add("drag-over");
        }
        e.preventDefault();
      }
    }, { passive: false });
    card.addEventListener("touchend", async (e) => {
      if (!draggedCard || draggedCard !== card)
        return;
      if (isDragging) {
        const touch = e.changedTouches[0];
        const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        const targetColumn = elementBelow?.closest(".kanban-column-body");
        if (targetColumn) {
          const newStatus = targetColumn.getAttribute("data-status");
          const itemId = card.getAttribute("data-item-id");
          if (newStatus && itemId) {
            await this.moveItemToStatus(itemId, newStatus);
          }
        }
        document.querySelectorAll(".kanban-column-body.drag-over").forEach((el) => {
          el.classList.remove("drag-over");
        });
        card.classList.remove("dragging");
        card.style.position = "";
        card.style.zIndex = "";
        card.style.pointerEvents = "";
        card.style.width = "";
        card.style.left = "";
        card.style.top = "";
        card.style.transform = "";
        isDragging = false;
        draggedCard = null;
      } else {
        const touchDuration = Date.now() - touchStartTime;
        const deltaX = Math.abs(e.changedTouches[0].clientX - touchStartX);
        const deltaY = Math.abs(e.changedTouches[0].clientY - touchStartY);
        if (touchDuration < 300 && deltaX < DRAG_THRESHOLD && deltaY < DRAG_THRESHOLD) {
          const target = e.target;
          if (target.tagName !== "INPUT" && target.tagName !== "A" && !target.closest("input") && !target.closest("a")) {
            const filePath = card.getAttribute("data-item-id");
            if (filePath && entry.file) {
              this.app.workspace.openLinkText(filePath, "", false);
            }
          }
        }
      }
      draggedCard = null;
    }, { passive: true });
  }
};

// PropertyRenderer.ts
var PropertyRenderer = class {
  constructor() {
    this.propertyTypes = {};
  }
  /**
   * Initializes the property types cache
   */
  setPropertyTypes(propertyTypes) {
    this.propertyTypes = propertyTypes;
  }
  /**
   * Renders a property value according to its type
   */
  renderPropertyValue(container, propertyId, value, file) {
    const propertyName = propertyId.split(".").slice(1).join(".");
    let propertyType = this.propertyTypes[propertyName] || null;
    if (!propertyType) {
      propertyType = this.inferPropertyType(value);
    }
    switch (propertyType) {
      case "checkbox":
        this.renderCheckbox(container, value);
        break;
      case "date":
        this.renderDate(container, value);
        break;
      case "datetime":
        this.renderDateTime(container, value);
        break;
      case "tags":
        container.setAttribute("data-property-type", "multitext");
        this.renderTags(container, value);
        break;
      case "multitext":
      case "list":
        this.renderList(container, value);
        break;
      case "number":
        this.renderNumber(container, value);
        break;
      default:
        this.renderText(container, value);
    }
  }
  /**
   * Infers a property type from its structure
   */
  inferPropertyType(value) {
    if (value === null || value === void 0)
      return null;
    if (value && typeof value === "object" && "icon" in value) {
      const icon = value.icon;
      if (icon === "lucide-check-square" || icon === "lucide-square") {
        return "checkbox";
      }
      if (icon === "lucide-calendar" || icon === "lucide-calendar-days") {
        if ("date" in value && !value.time) {
          return "date";
        }
        if ("date" in value && value.time) {
          return "datetime";
        }
        return "date";
      }
      if (icon === "lucide-clock") {
        return "datetime";
      }
      if (icon === "lucide-tags") {
        return "tags";
      }
      if (icon === "lucide-list" || icon === "lucide-list-ordered") {
        return "multitext";
      }
      if (icon === "lucide-binary" || icon === "lucide-hash") {
        return "number";
      }
    }
    const constructorName = value.constructor?.name || "";
    if (constructorName.includes("Boolean"))
      return "checkbox";
    if (constructorName.includes("Date")) {
      if (constructorName.includes("Time") || constructorName.includes("DateTime")) {
        return "datetime";
      }
      return "date";
    }
    if (constructorName.includes("Tag"))
      return "tags";
    if (constructorName.includes("List") || constructorName.includes("Multitext"))
      return "multitext";
    if (constructorName.includes("Number"))
      return "number";
    if (typeof value === "object") {
      if ("type" in value) {
        const type = value.type;
        if (type === "boolean" || type === "checkbox")
          return "checkbox";
        if (type === "date")
          return "date";
        if (type === "datetime")
          return "datetime";
        if (type === "tags")
          return "tags";
        if (type === "multitext" || type === "list")
          return "multitext";
        if (type === "number")
          return "number";
      }
      if (Array.isArray(value)) {
        return "multitext";
      }
    }
    if (typeof value === "boolean")
      return "checkbox";
    if (typeof value === "number")
      return "number";
    if (Array.isArray(value))
      return "multitext";
    return "text";
  }
  /**
   * Renders a checkbox
   */
  renderCheckbox(container, value) {
    const isChecked = this.getBooleanValue(value);
    const checkbox = container.createEl("input", {
      type: "checkbox"
    });
    checkbox.checked = isChecked;
    checkbox.disabled = true;
  }
  /**
   * Renders a date
   */
  renderDate(container, value) {
    const dateValue = this.getDateValue(value);
    if (dateValue) {
      const dateInput = container.createEl("input", {
        type: "date",
        cls: "metadata-input metadata-input-text mod-date"
      });
      dateInput.setAttribute("step", "any");
      dateInput.setAttribute("disabled", "true");
      const year = dateValue.getFullYear();
      const month = String(dateValue.getMonth() + 1).padStart(2, "0");
      const day = String(dateValue.getDate()).padStart(2, "0");
      dateInput.value = `${year}-${month}-${day}`;
    }
  }
  /**
   * Renders a date with time
   */
  renderDateTime(container, value) {
    const dateValue = this.getDateValue(value);
    if (dateValue) {
      const dateTimeInput = container.createEl("input", {
        type: "datetime-local",
        cls: "metadata-input metadata-input-text mod-datetime"
      });
      dateTimeInput.setAttribute("step", "any");
      dateTimeInput.setAttribute("disabled", "true");
      const year = dateValue.getFullYear();
      const month = String(dateValue.getMonth() + 1).padStart(2, "0");
      const day = String(dateValue.getDate()).padStart(2, "0");
      const hours = String(dateValue.getHours()).padStart(2, "0");
      const minutes = String(dateValue.getMinutes()).padStart(2, "0");
      dateTimeInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
    }
  }
  /**
   * Renders tags
   */
  renderTags(container, value) {
    const tags = this.getArrayValue(value);
    if (tags && tags.length > 0) {
      const listContainer = container.createDiv("value-list-container");
      tags.forEach((tag, index) => {
        if (index > 0) {
          const gap = listContainer.createSpan("value-list-gap");
          gap.innerHTML = "\n\n";
        }
        const element = listContainer.createSpan("value-list-element");
        const tagLink = element.createEl("a", { cls: "tag" });
        const tagName = tag.replace(/^#/, "");
        tagLink.textContent = tagName;
      });
    }
  }
  /**
   * Renders a list
   */
  renderList(container, value) {
    const items = this.getArrayValue(value);
    if (items && items.length > 0) {
      const listContainer = container.createDiv("value-list-container");
      items.forEach((item, index) => {
        if (index > 0) {
          const gap = listContainer.createSpan("value-list-gap");
          gap.innerHTML = "\n\n";
        }
        const element = listContainer.createSpan("value-list-element");
        element.textContent = item;
      });
    }
  }
  /**
   * Renders a number
   */
  renderNumber(container, value) {
    const numValue = this.getNumberValue(value);
    if (numValue !== null && numValue !== void 0) {
      container.textContent = String(numValue);
    }
  }
  /**
   * Renders text
   */
  renderText(container, value) {
    const textValue = this.getStringValue(value);
    container.textContent = textValue || "";
  }
  // ========== Utility functions to extract values ==========
  /**
   * Extracts a boolean value from a Value object
   */
  getBooleanValue(value) {
    if (typeof value === "boolean")
      return value;
    if (value && typeof value === "object") {
      if ("data" in value) {
        const data = value.data;
        if (typeof data === "boolean")
          return data;
        if (typeof data === "string")
          return data.toLowerCase() === "true";
        if (typeof data === "number")
          return data !== 0;
      }
      if ("value" in value) {
        const val = value.value;
        if (typeof val === "boolean")
          return val;
        if (typeof val === "string")
          return val.toLowerCase() === "true";
      }
      if ("checked" in value)
        return Boolean(value.checked);
    }
    if (typeof value === "string") {
      return value.toLowerCase() === "true" || value === "1";
    }
    if (value && typeof value === "object" && "icon" in value) {
      return false;
    }
    return false;
  }
  /**
   * Extracts a date value from a Value object
   */
  getDateValue(value) {
    if (value instanceof Date)
      return value;
    if (value && typeof value === "object") {
      if ("date" in value) {
        const date = value.date;
        if (date instanceof Date)
          return date;
        if (typeof date === "string") {
          const parsed = new Date(date);
          if (!isNaN(parsed.getTime()))
            return parsed;
        }
      }
      if (typeof value.toString === "function") {
        const str = value.toString();
        const date = new Date(str);
        if (!isNaN(date.getTime()))
          return date;
      }
      if ("value" in value) {
        return this.getDateValue(value.value);
      }
    }
    if (typeof value === "string") {
      const date = new Date(value);
      if (!isNaN(date.getTime()))
        return date;
    }
    return null;
  }
  /**
   * Extracts an array value from a Value object
   */
  getArrayValue(value) {
    if (value && typeof value === "object" && "data" in value) {
      const data = value.data;
      if (Array.isArray(data)) {
        return data.map((v) => {
          if (v && typeof v === "object" && "value" in v) {
            return this.getStringValue(v.value);
          }
          return this.getStringValue(v);
        });
      }
    }
    if (Array.isArray(value)) {
      return value.map((v) => {
        if (v && typeof v === "object" && "value" in v) {
          return this.getStringValue(v.value);
        }
        return this.getStringValue(v);
      });
    }
    if (value && typeof value === "object") {
      if ("value" in value) {
        return this.getArrayValue(value.value);
      }
      if ("items" in value && Array.isArray(value.items)) {
        return this.getArrayValue(value.items);
      }
    }
    return null;
  }
  /**
   * Extracts a numeric value from a Value object
   */
  getNumberValue(value) {
    if (value && typeof value === "object" && "data" in value) {
      const data = value.data;
      if (typeof data === "number")
        return data;
      if (typeof data === "string") {
        const num = parseFloat(data);
        if (!isNaN(num))
          return num;
      }
    }
    if (typeof value === "number")
      return value;
    if (typeof value === "string") {
      const num = parseFloat(value);
      if (!isNaN(num))
        return num;
    }
    if (value && typeof value === "object" && "value" in value) {
      return this.getNumberValue(value.value);
    }
    return null;
  }
  /**
   * Extracts a string value from a Value object
   */
  getStringValue(value) {
    if (value === null || value === void 0)
      return "";
    if (typeof value === "string")
      return value;
    if (typeof value === "number" || typeof value === "boolean")
      return String(value);
    if (value && typeof value === "object") {
      if ("data" in value) {
        return this.getStringValue(value.data);
      }
      if ("value" in value) {
        return this.getStringValue(value.value);
      }
      if ("text" in value) {
        return String(value.text);
      }
      if ("name" in value) {
        return String(value.name);
      }
      if (typeof value.toString === "function") {
        return String(value.toString());
      }
    }
    return String(value);
  }
  /**
   * Checks if a value is empty
   */
  isValueEmpty(value) {
    if (value === null || value === void 0) {
      return true;
    }
    if (value && typeof value === "object" && "icon" in value) {
      const icon = value.icon;
      if (icon === "lucide-file-question") {
        if (!("data" in value) || value.data === null || value.data === void 0) {
          return true;
        }
        return false;
      }
      if (icon === "lucide-check-square" || icon === "lucide-square") {
        return false;
      }
      if ("data" in value) {
        const data = value.data;
        if (data === null || data === void 0) {
          return true;
        }
        if (Array.isArray(data) && data.length === 0) {
          return true;
        }
        return false;
      }
      if ("date" in value) {
        const date = value.date;
        if (date === null || date === void 0) {
          return true;
        }
        return false;
      }
      return true;
    }
    if (Array.isArray(value) && value.length === 0) {
      return true;
    }
    return false;
  }
};

// KanbanView.ts
var KanbanView = class extends import_obsidian.BasesView {
  constructor(controller, containerEl) {
    super(controller);
    this.settings = {
      statusProperty: "",
      statuses: []
    };
    this.type = "kanban";
    this.statusPropertyId = null;
    this.propertyTypes = {};
    this.controller = controller;
    this.containerEl = containerEl;
  }
  async onload() {
    super.onload();
    await this.loadPropertyTypes();
    this.propertyRenderer = new PropertyRenderer();
    this.propertyRenderer.setPropertyTypes(this.propertyTypes);
    this.kanbanCard = new KanbanCard(
      this.propertyRenderer,
      this.propertyTypes,
      this.config,
      this.settings,
      this.app,
      (itemId, newStatus) => this.moveItemToStatus(itemId, newStatus)
    );
    this.loadSettings();
    this.render();
  }
  /**
   * Loads property types from .obsidian/types.json
   */
  async loadPropertyTypes() {
    try {
      const typesFile = this.app.vault.getAbstractFileByPath(".obsidian/types.json");
      if (typesFile) {
        const typesContent = await this.app.vault.read(typesFile);
        const types = JSON.parse(typesContent);
        this.propertyTypes = types.types || {};
        if (this.propertyRenderer) {
          this.propertyRenderer.setPropertyTypes(this.propertyTypes);
        }
      }
    } catch (e) {
      this.propertyTypes = {};
    }
  }
  /**
   * Loads settings from the view configuration
   */
  loadSettings() {
    if (!this.config) {
      return;
    }
    this.statusPropertyId = this.config.getAsPropertyId("statusProperty");
    if (this.statusPropertyId) {
      this.settings.statusProperty = this.config.getDisplayName(this.statusPropertyId);
    } else {
      const statusProperty = this.config.get("statusProperty");
      if (statusProperty && typeof statusProperty === "string") {
        this.settings.statusProperty = statusProperty;
        this.statusPropertyId = this.allProperties.find(
          (propId) => this.config.getDisplayName(propId) === statusProperty
        ) || null;
      }
    }
    const statuses = this.config.get("statuses");
    if (statuses && Array.isArray(statuses)) {
      this.settings.statuses = statuses;
    }
    const columnOrder = this.config.get("columnOrder");
    if (columnOrder && Array.isArray(columnOrder)) {
      this.settings.columnOrder = columnOrder;
    }
  }
  /**
   * Saves settings to the view configuration
   */
  saveSettings() {
    if (!this.config)
      return;
    if (this.statusPropertyId) {
      this.config.set("statusProperty", this.statusPropertyId);
    } else {
      const propertyId = this.allProperties.find(
        (propId) => this.config.getDisplayName(propId) === this.settings.statusProperty
      );
      if (propertyId) {
        this.config.set("statusProperty", propertyId);
        this.statusPropertyId = propertyId;
      } else {
        this.config.set("statusProperty", this.settings.statusProperty);
      }
    }
    this.config.set("statuses", this.settings.statuses);
    if (this.settings.columnOrder) {
      this.config.set("columnOrder", this.settings.columnOrder);
    }
  }
  /**
   * Called when the base data is updated
   */
  onDataUpdated() {
    this.loadSettings();
    this.render();
  }
  /**
   * Renders the complete Kanban view with all columns and cards
   */
  render() {
    const container = this.containerEl;
    container.empty();
    container.addClass("kanban-view-container");
    const data = this.data;
    if (!data || !data.data || data.data.length === 0) {
      container.createEl("div", {
        text: "No data available. Configure the view to get started.",
        cls: "kanban-empty"
      });
      return;
    }
    const statuses = this.getStatuses(data);
    if (statuses.length === 0) {
      statuses.push("backlog");
    }
    const kanbanContainer = container.createDiv("kanban-container");
    kanbanContainer.classList.add("kanban-columns-container");
    requestAnimationFrame(() => {
      const computedGap = getComputedStyle(kanbanContainer).gap;
      if (computedGap) {
        const gapValue = parseFloat(computedGap);
        if (!isNaN(gapValue)) {
          const dropZoneWidth = gapValue * 3;
          const dropZoneActiveWidth = gapValue * 3.6;
          kanbanContainer.style.setProperty("--kanban-drop-zone-width", `${dropZoneWidth}px`);
          kanbanContainer.style.setProperty("--kanban-drop-zone-active-width", `${dropZoneActiveWidth}px`);
        }
      }
    });
    this.setupContainerDragEvents(kanbanContainer);
    statuses.forEach((status, index) => {
      if (index > 0) {
        const dropZone = this.createColumnDropZone(statuses[index - 1], status);
        kanbanContainer.appendChild(dropZone);
      }
      const column = this.createColumn(status, data);
      kanbanContainer.appendChild(column);
    });
    if (statuses.length > 0) {
      const lastDropZone = this.createColumnDropZone(statuses[statuses.length - 1], null);
      kanbanContainer.appendChild(lastDropZone);
    }
  }
  /**
   * Creates a drop zone for reordering columns
   * @param beforeStatus - The status of the column before this zone
   * @param afterStatus - The status of the column after this zone (null if it's the last one)
   */
  createColumnDropZone(beforeStatus, afterStatus) {
    const dropZone = document.createElement("div");
    dropZone.className = "kanban-column-drop-zone";
    dropZone.setAttribute("data-before", beforeStatus);
    if (afterStatus) {
      dropZone.setAttribute("data-after", afterStatus);
    }
    dropZone.addEventListener("dragenter", (e) => {
      const container = dropZone.closest(".kanban-container");
      if (container && container.classList.contains("column-dragging")) {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.add("drop-zone-active");
      }
    });
    dropZone.addEventListener("dragover", (e) => {
      const container = dropZone.closest(".kanban-container");
      if (container && container.classList.contains("column-dragging")) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = "move";
        dropZone.classList.add("drop-zone-active");
      }
    });
    dropZone.addEventListener("dragleave", (e) => {
      const rect = dropZone.getBoundingClientRect();
      const x = e.clientX;
      const y = e.clientY;
      if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
        dropZone.classList.remove("drop-zone-active");
      }
    });
    dropZone.addEventListener("drop", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove("drop-zone-active");
      const draggedStatus = e.dataTransfer.getData("text/plain");
      if (draggedStatus && draggedStatus !== "backlog") {
        const afterStatusValue = dropZone.getAttribute("data-after");
        if (afterStatusValue) {
          this.reorderColumns(draggedStatus, afterStatusValue);
        } else {
          const currentStatuses = this.getStatuses(this.data);
          const lastStatus = currentStatuses[currentStatuses.length - 1];
          if (lastStatus && lastStatus !== draggedStatus) {
            const draggedIndex = currentStatuses.indexOf(draggedStatus);
            const newOrder = [...currentStatuses];
            newOrder.splice(draggedIndex, 1);
            newOrder.push(draggedStatus);
            this.settings.columnOrder = newOrder;
            this.saveSettings();
            this.render();
          }
        }
      }
    });
    return dropZone;
  }
  /**
   * Gets the list of statuses to display (backlog + configured or extracted statuses)
   * @param data - The base data
   * @returns List of statuses in the configured order
   */
  getStatuses(data) {
    const allStatuses = [];
    allStatuses.push("backlog");
    if (this.settings.statuses && this.settings.statuses.length > 0) {
      allStatuses.push(...this.settings.statuses);
    } else {
      if (this.settings.statusProperty && data.data) {
        const statusSet = /* @__PURE__ */ new Set();
        data.data.forEach((entry) => {
          const statusValue = this.getPropertyValue(entry, this.settings.statusProperty);
          if (statusValue) {
            statusSet.add(String(statusValue));
          }
        });
        allStatuses.push(...Array.from(statusSet).sort());
      }
    }
    if (this.settings.columnOrder && this.settings.columnOrder.length > 0) {
      const orderedStatuses = this.settings.columnOrder.filter(
        (status) => allStatuses.includes(status)
      );
      const newStatuses = allStatuses.filter(
        (status) => !this.settings.columnOrder.includes(status)
      );
      return [...orderedStatuses, ...newStatuses];
    }
    return allStatuses;
  }
  /**
   * Gets a property value from an entry
   * @param entry - The base entry
   * @param propertyName - The property name
   * @returns The property value or null
   */
  getPropertyValue(entry, propertyName) {
    if (!entry)
      return null;
    if (this.statusPropertyId && entry.getValue) {
      try {
        const value = entry.getValue(this.statusPropertyId);
        if (value === null)
          return null;
        if (value && typeof value === "object") {
          if ("value" in value) {
            return String(value.value);
          }
          if (typeof value.toString === "function") {
            return String(value.toString());
          }
        }
        return String(value);
      } catch (e) {
      }
    }
    if (propertyName && entry.properties && entry.properties[propertyName] !== void 0) {
      const val = entry.properties[propertyName];
      return val !== null && val !== void 0 ? String(val) : null;
    }
    return null;
  }
  /**
   * Creates a Kanban column for a given status
   * @param status - The column status
   * @param data - The base data
   * @returns The HTML element of the column
   */
  createColumn(status, data) {
    const column = document.createElement("div");
    column.className = "kanban-column";
    column.setAttribute("data-status", status);
    if (status !== "backlog") {
      column.setAttribute("draggable", "true");
      column.classList.add("kanban-column-draggable");
    } else {
      column.classList.add("kanban-column-fixed");
    }
    const header = column.createDiv("kanban-column-header");
    header.createEl("h3", { text: status, cls: "kanban-column-title" });
    const count = this.getItemsForStatus(status, data).length;
    header.createEl("span", {
      text: `${count}`,
      cls: "kanban-column-count"
    });
    const body = column.createDiv("kanban-column-body");
    body.setAttribute("data-status", status);
    const items = this.getItemsForStatus(status, data);
    items.forEach((item) => {
      const card = this.kanbanCard.createCard(item);
      body.appendChild(card);
    });
    this.setupDragAndDrop(column, body);
    this.setupColumnDragAndDrop(column);
    return column;
  }
  /**
   * Filters items for a given status
   * @param status - The status to search for
   * @param data - The base data
   * @returns List of items matching the status
   */
  getItemsForStatus(status, data) {
    if (!data.data) {
      return [];
    }
    if (status === "backlog") {
      if (!this.settings.statusProperty) {
        return data.data;
      }
      const validStatuses = this.getValidStatuses();
      return data.data.filter((entry) => {
        const statusValue = this.getPropertyValue(entry, this.settings.statusProperty);
        return !statusValue || !validStatuses.includes(String(statusValue));
      });
    }
    if (!this.settings.statusProperty) {
      return [];
    }
    return data.data.filter((entry) => {
      const statusValue = this.getPropertyValue(entry, this.settings.statusProperty);
      return String(statusValue) === status;
    });
  }
  getValidStatuses() {
    if (this.settings.statuses && this.settings.statuses.length > 0) {
      return this.settings.statuses;
    }
    if (!this.data || !this.data.data || !this.settings.statusProperty) {
      return [];
    }
    const statusSet = /* @__PURE__ */ new Set();
    this.data.data.forEach((entry) => {
      const statusValue = this.getPropertyValue(entry, this.settings.statusProperty);
      if (statusValue) {
        statusSet.add(String(statusValue));
      }
    });
    return Array.from(statusSet);
  }
  /**
   * Formats a date in Obsidian format (not currently used)
   */
  formatDate(date) {
    const day = String(date.getDate()).padStart(2, "0");
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
  }
  formatDateTime(date) {
    const day = String(date.getDate()).padStart(2, "0");
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const year = date.getFullYear();
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${day}/${month}/${year} ${hours}:${minutes}`;
  }
  /**
   * Configures drag and drop for cards in a column
   * @param column - The column element
   * @param body - The column body (drop zone)
   */
  setupDragAndDrop(column, body) {
    body.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      body.classList.add("drag-over");
    });
    body.addEventListener("dragleave", () => {
      body.classList.remove("drag-over");
    });
    body.addEventListener("drop", async (e) => {
      e.preventDefault();
      body.classList.remove("drag-over");
      const itemId = e.dataTransfer.getData("text/plain");
      const newStatus = body.getAttribute("data-status");
      if (itemId && newStatus) {
        await this.moveItemToStatus(itemId, newStatus);
      }
    });
    body.addEventListener("touchmove", (e) => {
      const draggingCard = document.querySelector(".kanban-card.dragging");
      if (draggingCard) {
        const touch = e.touches[0];
        const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        if (elementBelow?.closest(".kanban-column-body") === body) {
          body.classList.add("drag-over");
        } else {
          body.classList.remove("drag-over");
        }
      }
    }, { passive: true });
  }
  /**
   * Moves an item to a new status by updating its frontmatter
   * @param itemId - The file path
   * @param newStatus - The new status (or "backlog" to clear the property)
   */
  async moveItemToStatus(itemId, newStatus) {
    if (!this.settings.statusProperty || !itemId)
      return;
    try {
      const file = this.app.vault.getAbstractFileByPath(itemId);
      if (!file || !("stat" in file))
        return;
      if (newStatus === "backlog") {
        await this.app.fileManager.processFrontMatter(
          file,
          (frontmatter) => {
            if (frontmatter && frontmatter[this.settings.statusProperty] !== void 0) {
              delete frontmatter[this.settings.statusProperty];
            }
          }
        );
      } else {
        await this.app.fileManager.processFrontMatter(
          file,
          (frontmatter) => {
            if (!frontmatter) {
              frontmatter = {};
            }
            frontmatter[this.settings.statusProperty] = newStatus;
          }
        );
      }
    } catch (error) {
    }
  }
  /**
   * Configures drag events at the container level to handle column dragging
   * @param container - The main container of columns
   */
  setupContainerDragEvents(container) {
    const self = this;
    const handleDragStart = (e) => {
      const target = e.target;
      const column = target.closest(".kanban-column-draggable");
      if (column && !target.closest(".kanban-card")) {
        container.classList.add("column-dragging");
      }
    };
    const handleDragEnd = () => {
      container.classList.remove("column-dragging");
      container.querySelectorAll(".drop-zone-active").forEach((el) => {
        el.classList.remove("drop-zone-active");
      });
    };
    document.addEventListener("dragstart", handleDragStart, true);
    document.addEventListener("dragend", handleDragEnd, true);
    this.register(() => {
      document.removeEventListener("dragstart", handleDragStart, true);
      document.removeEventListener("dragend", handleDragEnd, true);
    });
  }
  /**
   * Configures drag and drop for reordering columns
   * @param column - The column element to make draggable
   */
  setupColumnDragAndDrop(column) {
    const status = column.getAttribute("data-status");
    if (status === "backlog") {
      return;
    }
    const header = column.querySelector(".kanban-column-header");
    if (!header)
      return;
    let isColumnDragging = false;
    let touchStartX = 0;
    let touchStartY = 0;
    let draggedColumn = null;
    const DRAG_THRESHOLD = 5;
    column.addEventListener("dragstart", (e) => {
      const target = e.target;
      if (target.closest(".kanban-card")) {
        return;
      }
      if (!target.closest(".kanban-column-header")) {
        return;
      }
      e.stopPropagation();
      column.classList.add("column-dragging");
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", status || "");
      const container = column.closest(".kanban-container");
      if (container) {
        container.classList.add("column-dragging");
      }
    });
    column.addEventListener("dragend", () => {
      column.classList.remove("column-dragging");
      const container = column.closest(".kanban-container");
      if (container) {
        container.classList.remove("column-dragging");
        container.querySelectorAll(".drop-zone-active").forEach((el) => {
          el.classList.remove("drop-zone-active");
        });
      }
    });
    header.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      isColumnDragging = false;
      draggedColumn = column;
    }, { passive: true });
    header.addEventListener("touchmove", (e) => {
      if (!draggedColumn || draggedColumn !== column)
        return;
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - touchStartX);
      const deltaY = Math.abs(touch.clientY - touchStartY);
      if ((deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) && !isColumnDragging) {
        isColumnDragging = true;
        column.classList.add("column-dragging");
        const container = column.closest(".kanban-container");
        if (container) {
          container.classList.add("column-dragging");
        }
        e.preventDefault();
      } else if (isColumnDragging) {
        const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        const dropZone = elementBelow?.closest(".kanban-column-drop-zone");
        if (dropZone) {
          document.querySelectorAll(".kanban-column-drop-zone.drop-zone-active").forEach((el) => {
            el.classList.remove("drop-zone-active");
          });
          dropZone.classList.add("drop-zone-active");
        }
        e.preventDefault();
      }
    }, { passive: false });
    header.addEventListener("touchend", async (e) => {
      if (!draggedColumn || draggedColumn !== column)
        return;
      if (isColumnDragging) {
        const touch = e.changedTouches[0];
        const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        const dropZone = elementBelow?.closest(".kanban-column-drop-zone");
        if (dropZone && status) {
          const beforeStatus = dropZone.getAttribute("data-before");
          const afterStatus = dropZone.getAttribute("data-after");
          if (afterStatus && afterStatus !== status) {
            await this.reorderColumns(status, afterStatus);
          } else if (!afterStatus && beforeStatus && beforeStatus !== status) {
            const currentStatuses = this.getStatuses(this.data);
            const lastStatus = currentStatuses[currentStatuses.length - 1];
            if (lastStatus && lastStatus !== status) {
              await this.reorderColumns(status, lastStatus);
            }
          }
        }
        column.classList.remove("column-dragging");
        const container = column.closest(".kanban-container");
        if (container) {
          container.classList.remove("column-dragging");
          container.querySelectorAll(".drop-zone-active").forEach((el) => {
            el.classList.remove("drop-zone-active");
          });
        }
        isColumnDragging = false;
        draggedColumn = null;
      }
    }, { passive: true });
  }
  /**
   * Reorders columns by moving one column before another
   * @param draggedStatus - The status of the dragged column
   * @param dropStatus - The status of the column before which to insert
   */
  reorderColumns(draggedStatus, dropStatus) {
    const currentStatuses = this.getStatuses(this.data);
    const draggedIndex = currentStatuses.indexOf(draggedStatus);
    const dropIndex = currentStatuses.indexOf(dropStatus);
    if (draggedIndex === -1 || dropIndex === -1)
      return;
    const newOrder = [...currentStatuses];
    newOrder.splice(draggedIndex, 1);
    newOrder.splice(dropIndex, 0, draggedStatus);
    this.settings.columnOrder = newOrder;
    this.saveSettings();
    this.render();
  }
};

// main.ts
var import_obsidian2 = require("obsidian");
var KanbanViewPlugin = class extends import_obsidian2.Plugin {
  /**
   * Loads the plugin and registers the Kanban view
   */
  async onload() {
    this.registerBasesView("kanban", {
      name: "Kanban",
      icon: "lucide-columns-2",
      factory: (controller, containerEl) => {
        return new KanbanView(controller, containerEl);
      },
      options: () => [
        {
          type: "property",
          key: "statusProperty",
          displayName: "Property for columns",
          placeholder: "Select a property"
        },
        {
          type: "multitext",
          key: "statuses",
          displayName: "Custom statuses (optional)",
          default: []
        }
      ]
    });
  }
  onunload() {
  }
};
